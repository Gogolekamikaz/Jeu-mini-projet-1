package ch.epfl.cs107.play.game.superpacman.area;

import ch.epfl.cs107.play.game.areagame.AreaGraph;
import ch.epfl.cs107.play.game.superpacman.actor.*;
import ch.epfl.cs107.play.math.DiscreteCoordinates;
import ch.epfl.cs107.play.window.Window;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class SuperPacmanAutoGeneratedMazeBehavior extends SuperPacmanBehavior {

    /// Random generator for the maze
    protected final Random rand;

    private DiscreteCoordinates spawnPoint;
    ArrayList<Ghost> ghostActors = new ArrayList<Ghost>();
    AreaGraph areaGraph;

    private DiscreteCoordinates[] possibleSpwanPoint = {new DiscreteCoordinates(1, getHeight()-1),
                                                        new DiscreteCoordinates(getWidth()-1, getHeight()-1),
                                                        new DiscreteCoordinates(getWidth()-1, 1)};


    /**
     * Default AutoGeneratedMazeBehavior Constructor
     *
     * @param window (Window): graphic context, not null
     * @param width
     * @param height
     */
    public SuperPacmanAutoGeneratedMazeBehavior(Window window, int width, int height, int seed){
        super(window, width, height);

        for(int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                setCell(x, y, new SuperPacmanCell(x, y, SuperPacmanBehavior.SuperPacmanCellType.NONE));
            }
        }

        rand = new Random(seed);

        generateMazeFeatures(width, height);
        createMaze(width, height);

            /*if(color != SuperPacmanBehavior.SuperPacmanCellType.WALL){
                    areaGraph.addNode(coordinates , cell.hasSideEdge("LEFT",coordinates,height), cell.hasSideEdge("UP",coordinates,height), cell.hasSideEdge("RIGHT", coordinates,height),cell.hasSideEdge("DOWN", coordinates,height));
                }*/

    }

    private void createMaze(int width, int height){

        List<DiscreteCoordinates> lastMoves = new ArrayList<>();
    }

    private void generateMazeFeatures(int width, int height){

        //Initialize the outer walls
        for (int x = 0; x < width; x++) {
            for (int y=1; y<height-1; y++){
                ((SuperPacmanCell)getCell(x, y)).setType(SuperPacmanBehavior.SuperPacmanCellType.WALL);
            }
        }

        //Initialize the ghosts
        int ghostNumber = (int)Math.ceil(width/15)%2 == 0? (int)Math.ceil(width/15) : (int)Math.ceil(width/15)+1;
        DiscreteCoordinates middleCoordinates = new DiscreteCoordinates((int)Math.ceil(width/2), (int)Math.ceil(height/2));

       /* for (int i = -ghostNumber/2; i < ghostNumber/2; i++) {
            ((SuperPacmanMazeCell)getCell(middleCoordinates.x+i, middleCoordinates.y+1)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_WITH_BLINKY);
            if(i%2 == 0){
                ((SuperPacmanMazeCell)getCell(middleCoordinates.x+i, middleCoordinates.y-1)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_WITH_INKY);
            } else {
                ((SuperPacmanMazeCell)getCell(middleCoordinates.x+i, middleCoordinates.y-1)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_WITH_PINKY);
            }
        }*/

        //Initialize the Door
        for(int i = 4; i<6; i++){
            ((SuperPacmanCell)getCell(i, 0)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_EMPTY);
            ((SuperPacmanCell)getCell(i, 1)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_EMPTY);
        }

        //Initialize Spawn Point
        spawnPoint = possibleSpwanPoint[rand.nextInt(3)];
        ((SuperPacmanCell)getCell(spawnPoint.x, spawnPoint.y)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_EMPTY);
    }


    public DiscreteCoordinates getSpawnPoint() {
        return spawnPoint;
    }

}
