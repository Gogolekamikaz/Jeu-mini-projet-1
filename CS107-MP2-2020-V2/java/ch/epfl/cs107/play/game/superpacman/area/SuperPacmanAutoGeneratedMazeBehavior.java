package ch.epfl.cs107.play.game.superpacman.area;

import ch.epfl.cs107.play.game.areagame.AreaGraph;
import ch.epfl.cs107.play.game.areagame.AutoGeneratedMazeBehavior;
import ch.epfl.cs107.play.game.areagame.actor.Interactable;
import ch.epfl.cs107.play.game.areagame.actor.Orientation;
import ch.epfl.cs107.play.game.areagame.handler.AreaInteractionVisitor;
import ch.epfl.cs107.play.game.superpacman.actor.*;
import ch.epfl.cs107.play.math.DiscreteCoordinates;
import ch.epfl.cs107.play.math.Vector;
import ch.epfl.cs107.play.window.Window;

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;

public class SuperPacmanAutoGeneratedMazeBehavior extends AutoGeneratedMazeBehavior {

    DiscreteCoordinates spawnPoint;
    ArrayList<Ghost> ghostActors = new ArrayList<Ghost>();
    AreaGraph areaGraph;

    private DiscreteCoordinates[] possibleSpwanPoint = {new DiscreteCoordinates(1, getHeight()-1),
                                                        new DiscreteCoordinates(getWidth()-1, getHeight()-1),
                                                        new DiscreteCoordinates(getWidth()-1, 1)};


    /**
     * Default AutoGeneratedMazeBehavior Constructor
     *
     * @param window (Window): graphic context, not null
     * @param width
     * @param height
     */
    public SuperPacmanAutoGeneratedMazeBehavior(Window window, int width, int height) throws Exception {
        super(window, width, height, 1L);
        areaGraph = new AreaGraph();

        for(int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                setCell(x, y, new SuperPacmanMazeCell(x, y, SuperPacmanBehavior.SuperPacmanCellType.NONE));
            }
        }

        generateMazeFeatures(width, height);
        createMaze(width, height);

            /*if(color != SuperPacmanBehavior.SuperPacmanCellType.WALL){
                    areaGraph.addNode(coordinates , cell.hasSideEdge("LEFT",coordinates,height), cell.hasSideEdge("UP",coordinates,height), cell.hasSideEdge("RIGHT", coordinates,height),cell.hasSideEdge("DOWN", coordinates,height));
                }*/

    }

    private void createMaze(int width, int height){

        List<DiscreteCoordinates> lastMoves = new ArrayList<>();
    }

    private void generateMazeFeatures(int width, int height){

        //Initialize the outer walls
        for (int x = 0; x < width; x++) {
            for (int y=1; y<height-1; y++){
                ((SuperPacmanMazeCell)getCell(x, y)).setType(SuperPacmanBehavior.SuperPacmanCellType.WALL);
            }
        }

        //Initialize the ghosts
        int ghostNumber = (int)Math.ceil(width/15)%2 == 0? (int)Math.ceil(width/15) : (int)Math.ceil(width/15)+1;
        DiscreteCoordinates middleCoordinates = new DiscreteCoordinates((int)Math.ceil(width/2), (int)Math.ceil(height/2));

        for (int i = -ghostNumber/2; i < ghostNumber/2; i++) {
            ((SuperPacmanMazeCell)getCell(middleCoordinates.x+i, middleCoordinates.y+1)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_WITH_BLINKY);
            if(i%2 == 0){
                ((SuperPacmanMazeCell)getCell(middleCoordinates.x+i, middleCoordinates.y-1)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_WITH_INKY);
            } else {
                ((SuperPacmanMazeCell)getCell(middleCoordinates.x+i, middleCoordinates.y-1)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_WITH_PINKY);
            }
        }

        //Initialize the Door
        for(int i = 4; i<6; i++){
            ((SuperPacmanMazeCell)getCell(i, 0)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_EMPTY);
            ((SuperPacmanMazeCell)getCell(i, 1)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_EMPTY);
        }

        //Initialize Spawn Point
        spawnPoint = possibleSpwanPoint[rand.nextInt(3)];
        ((SuperPacmanMazeCell)getCell(spawnPoint.x, spawnPoint.y)).setType(SuperPacmanBehavior.SuperPacmanCellType.FREE_EMPTY);
    }

    protected void registerActors(MazeLevel area){
        DiscreteCoordinates coordinates;
        int height = getHeight();
        int width = getWidth();
        for(int x = 0; x < width; ++x ) {
            for(int y = 0; y < height; ++y){
                SuperPacmanMazeCell cell = (SuperPacmanMazeCell) getCell(x,y);
                SuperPacmanBehavior.SuperPacmanCellType color = cell.getType();

                coordinates = new DiscreteCoordinates(x,y);
                switch(color){
                    case WALL:
                        Wall wallActor = new Wall(area,coordinates,cell.getWallNeighborhood(x,y));
                        area.registerActor(wallActor);
                        break;
                    case FREE_WITH_BONUS:
                        Bonus bonus = new Bonus(area, coordinates);
                        area.registerActor(bonus);
                        break;
                    case FREE_WITH_CHERRY:
                        Cherry cherry = new Cherry(area, coordinates);
                        area.registerActor(cherry);
                        break;
                    case FREE_WITH_DIAMOND:
                        Diamond diamond = new Diamond(area, coordinates);
                        area.registerActor(diamond);
                        area.addDiamond();
                        break;
                    case FREE_WITH_BLINKY:
                        Vector positionRefuge = new Vector((float)(x),(float)(y));
                        DiscreteCoordinates positionRefugeCoord = new DiscreteCoordinates(x,y);
                        Blinky blinky = new Blinky(area, Orientation.UP, coordinates, positionRefuge, positionRefugeCoord);
                        area.registerActor(blinky);
                        ghostActors.add(blinky);
                    case FREE_WITH_INKY:
                        Vector positionRefuge2 = new Vector((float)(x),(float)(y));
                        DiscreteCoordinates positionRefugeCoord2 = new DiscreteCoordinates(x,y);
                        Inky inky = new Inky(area, Orientation.UP, coordinates, positionRefuge2, positionRefugeCoord2);
                        area.registerActor(inky);
                        ghostActors.add(inky);
                    case FREE_WITH_PINKY:
                        Vector positionRefuge3 = new Vector((float)(x),(float)(y));
                        DiscreteCoordinates positionRefugeCoord3 = new DiscreteCoordinates(x,y);
                        Pinky pinky = new Pinky(area, Orientation.UP, coordinates, positionRefuge3 , positionRefugeCoord3);
                        area.registerActor(pinky);
                        ghostActors.add(pinky);

                }
            }
        }
    }



    private static boolean ghostActorsExist(ArrayList<Ghost> arraylist){
        if(arraylist.size() > 0){
            return true;
        }
        else{
            return false;
        }
    }

    protected Queue<Orientation> shortestPath(DiscreteCoordinates origine, DiscreteCoordinates arrivee){
        //DiscreteCoordinates tryArrival = new DiscreteCoordinates(14,15);
        //DiscreteCoordinates tryArrival2 = new DiscreteCoordinates(14,13);
        //Queue<Orientation> test = areaGraph.shortestPath(origine, tryArrival);
        //Queue<Orientation> test2 = areaGraph.shortestPath(origine, tryArrival2);
        //System.out.println(test);
        //System.out.println(test2);
        Queue<Orientation> sequence = areaGraph.shortestPath(origine, arrivee);
        System.out.println(sequence);
        return areaGraph.shortestPath(origine, arrivee);
    }

    protected void scareCheck(SuperPacmanPlayer player){
        if(player.isInvincible() && ghostActorsExist(ghostActors)){
            for(Ghost ghost : ghostActors){
                ghost.setAfraid(player);
            }
        }
    }

    public class SuperPacmanMazeCell extends AutoGeneratedMazeBehavior.Cell{

        private SuperPacmanBehavior.SuperPacmanCellType type;

        /**
         * Default Cell constructor
         *  @param x (int): x-coordinate of this cell
         * @param y (int): y-coordinate of this cell
         * @param type
         */
        protected SuperPacmanMazeCell(int x, int y, SuperPacmanBehavior.SuperPacmanCellType type) {
            super(x, y);
            this.type = type;
        }

        @Override
        protected boolean canLeave(Interactable entity) {
            return true;
        }

        @Override
        protected boolean canEnter(Interactable entity) {   //If cell already has an entity occupying all the cell space, it's not traversable
            if(this.hasNonTraversableContent()){
                return false;
            }
            else{
                return true;
            }
        }

        @Override
        public boolean isCellInteractable() {
            return false;
        }

        @Override
        public boolean isViewInteractable() {
            return false;
        }

        @Override
        public void acceptInteraction(AreaInteractionVisitor v) {
        }

        private boolean cellExists(int x, int y){
            try {
                getCell(x, y);
            } catch (ArrayIndexOutOfBoundsException e){
                return false;
            }
            return true;
        }

        private SuperPacmanBehavior.SuperPacmanCellType getType(){
            return this.type;
        }

        private void setType(SuperPacmanBehavior.SuperPacmanCellType type){
            this.type = type;
        }

        private boolean[][] getWallNeighborhood(int x, int y){
            boolean[][] neigborhood = new boolean[3][3];
            for(int xcord = x-1, i = 0; xcord <= x+1; ++xcord , ++i){
                for(int ycord = y+1, j = 0; ycord >= y-1; --ycord, ++j){
                    if(cellExists(xcord, ycord) &&  ((SuperPacmanMazeCell)getCell(x,y)).getType() == SuperPacmanBehavior.SuperPacmanCellType.WALL){
                        neigborhood[i][j] = true;
                    }
                    else{
                        neigborhood[i][j] = false;
                    }
                }
            }
            return neigborhood;
        }

        protected boolean hasSideEdge(String Side, DiscreteCoordinates coordinates, int height){

            SuperPacmanBehavior.SuperPacmanCellType color = null;
            int x = 0;
            int y = 0;

            if(Side == "LEFT") {
                x = coordinates.x - 1;
                y = coordinates.y;
            }

            else if(Side == "RIGHT") {
                x = coordinates.x + 1;
                y = coordinates.y;

            }
            else if(Side == "DOWN") {
                x = coordinates.x;
                y = coordinates.y - 1 ;
            }
            else if(Side == "UP") {
                x = coordinates.x;
                y = coordinates.y + 1 ;
            }

            if(cellExists(x,y)){
                SuperPacmanBehavior.SuperPacmanCellType currentType = ((SuperPacmanMazeCell)getCell(x,y)).getType();
                if (currentType != SuperPacmanBehavior.SuperPacmanCellType.WALL){
                    return true;
                }
                else{
                    return false;
                }
            }
            else {
                return false;
            }
        }
    }
}
